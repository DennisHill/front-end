# 闭包

之前说到执行上下文环境，在函数执行完毕后，会被销毁，数据也被清除。但是有种情况是例外，在函数执行完后，上下文环境不会被销毁，这就是**闭包**。

```
function fn () {
    var a = 100;
    return function bar () {
        console.log(a);
    }
}
var f = fn();
f(); // 100
```

1. **当执行了`var f = fn()`之后，我们声明了一个变量`f`，这个变量就是`bar`函数。**
2. **当执行`f()`时，其实就是在执行`bar`函数。**
3. **由于`bar`函数的作用域内没有变量`a`，于是，对于`bar`作用域，`a` 是一个自由变量。**
4. **按照作用域链的原则，会去创建`bar`函数的作用域(也就是`fn`作用域)中查找`a`变量。**
5. **而若要确定在作用域中的某个变量的值，就要结合作用域对应的执行上下文环境中寻找变量的值**
6. **因此，虽然`fn`函数已经执行完毕，但是，他的上下文环境并不能销毁，数据也不能清除。**

--------

### 以上，就是造成闭包的原因。