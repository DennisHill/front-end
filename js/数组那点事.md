> 天生我材必有用 千金散尽还复来

最近面试时遇到了一个问题。与数组相关的，在此记录一下。

面试官： 数组与链表相比，优势在哪里？

想了想，回答道：链表中，如果想访问某个元素，需要从链表头部开始，依次访问。数组可以通过下标访问，比链表快。

面试官：为什么数组比链表快？

唉，惭愧，没答上来。回来赶紧查资料，看是咋回事。

原来在编程语言中，比如`java`中，想要使用一个数组，需要先进行声明

```

int[] arr1 = new int[6];

String[] arr2 = {"a", "b", "c"};

```
以上定义方式，有两个个共同点

- 数组中，元素类型都一样。都是`int`、`String`等。
- 确定了长度。

所以，代码在执行的时候，当看到我们在代码中定义了数组时，就会在内存中，分配一片连续的内存，用于存放这些数据。因为元素种类相同，这样每个元素所占用的内存空间都是一样的。这样当我们按下标访问元素时，只需要进行一个简单的计算，就可以知道我们要访问的元素，位于内存的哪个地方。这样，肯定是要比链表从头开始访问要快了。

**然而，事情没这么简单**

`js`中的数组可没这么简单，因为`js`的数组可以存储不同类型的数据

```
var arr1 = [1, '2', false, {}, null, function () {}]

```

上述代码是合法的。所以，`js`到底是怎么做的呢？

很简单，`js`数组底层是用链表实现的。所以，看上去是一个数组，然而，其实确实一个“假数组”。其底层的实现，是通过链表完成的。

然而，随着`js`的发展，这种情况其实得到了好转。当`js`引擎执行代码时，发现数组中，如果是同样的元素，其实是会在内存中分配连续的空间，这个时候，`js`的数组在底层内存中的存放方式，跟真正的数组，就是一样的了。

所以，我们在写代码时，尽可能的避免在一个数组中出现不同种类的元素，以优化代码的性能。尤其是当遇到长度比较大的数组时，还是可以优化不少性能的。

```
// bad
var arr1 = [1, 'a', 2];

// good
var arr1 = [1, 2, 3];

```
