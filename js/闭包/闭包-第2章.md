# 执行上下文环境

先来看几段代码
```
console.log(a); // Uncaught ReferenceError: a is not defined
```
```
var a;
console.log(a);// undefined
```
```
var a = 10;
console.log(a);// 10
```
```
console.log(a);// undefined
var a = 10;
```
- 第一段代码，很正常。因为a没有定义。
- 第二段，很正常。因为a定义了，却没有赋值。
- 第三段，再正常不过了。不解释
- 第四段，略不正常。因为在`console.log`之后，才定义了`a`，但是，居然没有报错。
---------------------
对于以上四段代码，只有稍有一些经验的前端，就能很清楚的回答上来，并且有一个专有名词`变量提升`
<br>
没错，就是变量提升。
### 为什么会有变量提升？
> 是的，我曾在面试里遭遇过这个问题。当时心里一阵MMP，我又没去看过js解释器的代码，我怎么知道，为什么函数在执行时要搞一个变量提升啊~ _ ~

现在想想，也许面试官是让我回答在代码运行前会有哪些“准备工作”吧
1. **变量、函数表达式声明，默认赋值为`undefined`**
2. **对`this`赋值**
3. **函数声明赋值**

**这种准备工作就被称之为`执行上下文环境`。**
> 所以，面试官也许考的是执行上下文环境的问题。惭愧，当时并没有答上来。

**对于上述执行上下文环境来说，说的是全局代码。如果是函数体，在执行之前，还有以下“准备工作”**
1. **`arguments`赋值**
2. **参数赋值**
3. **确定函数体内部自由变量的作用域(后面会写)**

**函数每被调用一次，都会产生一个新的执行上下文环境**

----------------------

### 总结一下

#### 全局执行上下文环境的数据

类型 | 值
---|---
普通变量以及函数表达式 | 赋值为undefined
函数声明 | 直接赋值
this | 直接赋值

#### 函数执行上下文环境的数据

类型 | 值
---|---
普通变量以及函数表达式 | 赋值为undefined
函数声明 | 直接赋值
this | 直接赋值
参数 | 直接赋值
arguments | 直接赋值
自由变量的取值作用域 | 直接赋值

------------------------
#### 执行上下文环境的一些结论
1. **执行全局代码时，会产生一个执行上下文环境。**
2. **每次调用函数都又会产生执行上下文环境。**
3. **当函数调用完成时，这个上下文环境以及其中的数据都会被消除。**
4. **处于活动状态的执行上下文环境只有一个**

------------------------

最后，我所理解的执行上下文环境就是：

**在执行代码之前，把所有的变量都事先拿出来，有的直接赋值了(如函数声明，`this`)，有的先用`undefined`占个位置。**
