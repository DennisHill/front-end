> 飞流直下三千尺 疑是银河落九天

### 基本思路

构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

![image](https://mycloudserver.oss-cn-beijing.aliyuncs.com/markdown/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif?Expires=1586351537&OSSAccessKeyId=TMP.3KewP6Bfoq81RhGYskjog4H9stqj9QhQEkFPUkvvsfuRwiLiNhmiY9aa7TKBxcxtBEYKGmAnVs6S4NSThK1rNhjrc58Dds&Signature=luwJzwFeiw0toOpiQvmXnFiYyJk%3D)

### 代码实现

```
function sort(arr) {
    var len = arr.length;
    var preIndex, current;
    for(var i = 1; i < len; i++) {
        preIndex = i - 1;
        current = arr[i];
        while(preIndex >= 0 && arr[preIndex] > current) {
            arr[preIndex + 1] = arr[preIndex];
            preIndex--;
        }
        arr[preIndex + 1] = current;
    }
    return arr;
}

var arr = generateArray(5); // [16, 13, 8, 26, 25]
sort(arr); //[8, 13, 16, 25, 26]
```

## 执行过程


1. `i = 1 ; preIndex = 0 ; current = 13`

- `preIndex >= 0 && arr[preIndex] > current => arr[preIndex + 1] = arr[preIndex] => [16, 16, 8, 26, 25]` 

`arr[preIndex + 1] = current => [13, 16, 8, 26, 25]`

2. `i = 2 ; preIndex = 1 ; current = 8`

- `preIndex >= 0 && arr[preIndex] > current => arr[preIndex + 1] = arr[preIndex] => [13, 16, 16, 26, 25] ; preIndex = 0`
- `preIndex >= 0 && arr[preIndex] > current => arr[preIndex + 1] = arr[preIndex] => [13, 13, 16, 26, 25] ; preIndex = -1`

`arr[preIndex + 1] = current => [8, 13, 16, 26, 25]`

3. `i = 3 ; preIndex = 2 ; current = 26`

- `preIndex >= 0 && !(arr[preIndex] > current) => break while loop => arr[preIndex + 1] = current => [8, 13, 16, 26, 25]`

`arr[preIndex + 1] = current => [8, 13, 16, 26, 25]`

4. `i = 4 ; preIndex = 3 ; current = 26`

- `j = 4 && j < 5  =>  arr[4] > arr[minIndex]`

`swap(arr[3], arr[minIndex]) => [13, 16, 25, 26, 67]`

5. `i = 4 ; minIndex = 4`

- `j = 5 && !(j < 5) => break inner loop`

`swap(arr[3], arr[minIndex]) => [13, 16, 25, 26, 67]`

> 最终结果 `[13, 16, 25, 26, 67]`

### 总结

冒泡排序需要两层循环，时间复杂度为`O(n^2)`

内循环，每次都会把最小的放在第一位


